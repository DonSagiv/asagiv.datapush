@page "/"
@using Grpc.Net.Client
@using System.Reactive.Linq
@using System.Reactive
@using asagiv.pushrocket.common.Models
@using asagiv.pushrocket.ui.common.ViewModels
@inject MainViewModel ViewModel
@inject IMessageService MessageService

<Div>

    <Div class="d-flex align-items-stretch">

        <Div class="form-floating flex-grow-1" Margin="Margin.Is2">

            <TextEdit InputMode="TextInputMode.Url"
                      Class="form-control"
                      id="floatingInput"
                      @bind-Text="@ViewModel.ConnectionString"
                      placeholder=" " />

            <FieldLabel For="floatingInput">Connection String</FieldLabel>

        </Div>

        <Button Color="Color.Primary" Margin="Margin.Is2"
                Clicked="@(x => ViewModel.ConnectCommand.Execute(null))">
            Connect
        </Button>

    </Div>

    @if (ViewModel.IsConnected)
    {
        <Div Class="d-flex align-items-stretch" Margin="Margin.Is2">
            <Select TValue="string" @bind-SelectedValue="@ViewModel.SelectedDestinationNode">
                @foreach (var destinationNode in ViewModel.DestinationNodes)
                {
                    <SelectItem Value="@destinationNode">@destinationNode</SelectItem>
                }
            </Select>
        </Div>

        <Div Class="d-flex align-items-stretch">
            <Button Color="Color.Primary" Margin="Margin.Is2" Clicked="@(x => ViewModel.PushFilesCommand.Execute(null))" Block>Select Files</Button>
        </Div>
    }
    else
    {
        <Div>
            <Text TextAlignment="TextAlignment.Center">
                Please connect to a PushRocket server.
            </Text>
        </Div>
    }

    @foreach (var context in ViewModel.PushContexts.Reverse())
    {
        <Div class="m-2 p-2" Style="background-color: #DDDDDD;border-color: #444444;border-radius: 5px">

            <Div Class="d-flex justify-content-between align-items-center" Margin="Margin.Is2">

                <Text>@context.Name</Text>

                <Div Class="d-flex justify-content-right align-items-center">

                    @switch (context.Status)
                    {
                        case DeliveryStatus.InProgress:
                            <Icon Name="IconName.Hourglass" TextColor="TextColor.Primary" Margin="Margin.Is2" IconStyle="IconStyle.Regular"></Icon>
                            break;
                        case DeliveryStatus.Successful:
                            <Icon Name="IconName.Check" TextColor="TextColor.Success" Margin="Margin.Is2" IconStyle="IconStyle.Solid"></Icon>
                            break;
                        default:
                            <Icon Name="IconName.ExclamationTriangle" TextColor="TextColor.Primary" Margin="Margin.Is2" IconStyle="IconStyle.Regular"></Icon>
                            break;
                    }

                    <Icon Name="IconName.Times" TextColor="TextColor.Default" Margin="Margin.Is2" IconStyle="IconStyle.Solid"
                      Style="cursor:pointer" Clicked="@(() => ViewModel.RemoveContext(context))"></Icon>

                </Div>

            </Div>

            @if (context.Status == DeliveryStatus.InProgress)
            {
                <Div Margin="Margin.Is2">

                    <progress max="@context.TotalNumberOfBlocks"
                      style="height: 30px;width: 100%"
                      value="@context.NumberOfBlocksPushed" />

                </Div>
            }

        </Div>

    }

</Div>

@code
{
    protected override async Task OnInitializedAsync()
    {
        ViewModel.ErrorObservable
            .SelectMany(ShowErrorNotifier)
            .Subscribe();

        ViewModel.PropertyChanged += async (s, e) => await InvokeAsync(() => this.StateHasChanged());

        ViewModel.PushContexts.CollectionChanged += async (s, e) =>
        {
            await InvokeAsync(() => this.StateHasChanged());

            var newItems = e.NewItems?.OfType<DataPushContext>();

            if (newItems == null)
            {
                return;
            }

            foreach (var newItem in newItems)
            {
                newItem.PropertyChanged += async (t, f) => await InvokeAsync(() => this.StateHasChanged());
            }
        };

        await ViewModel.Database.ConnectAsync();

        await base.OnInitializedAsync();
    }

    private async Task<Unit> ShowErrorNotifier(string errorMessage)
    {
        await MessageService.Error(errorMessage, "Error");

        return Unit.Default;
    }
}